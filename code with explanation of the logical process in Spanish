import os
import fitz  # PyMuPDF
import cv2
import pytesseract
import re
import logging
import itertools
from rapidfuzz import process, fuzz

# Configuración del registro (logs esenciales)
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger()

def extraer_texto_pdf(pdf_ruta):
    """Extrae texto de la primera página de un PDF digital usando PyMuPDF."""
    try:
        documento = fitz.open(pdf_ruta)
        pagina = documento[0]
        texto_completo = pagina.get_text().strip()
        return texto_completo
    except Exception as e:
        logger.error(f"Error al extraer texto del PDF {pdf_ruta}: {e}")
        return ""

def extraer_texto_ocr(pdf_ruta):
    """Extrae texto de la primera página de un PDF escaneado usando OCR."""
    try:
        documento = fitz.open(pdf_ruta)
        pagina = documento[0]
        for img_index, img in enumerate(pagina.get_images(full=True)):
            xref = img[0]
            base_img = documento.extract_image(xref)
            imagen_ruta = f"pagina_1_imagen_{img_index + 1}.png"
            with open(imagen_ruta, "wb") as f:
                f.write(base_img["image"])
            
            imagen = cv2.imread(imagen_ruta)
            gris = cv2.cvtColor(imagen, cv2.COLOR_BGR2GRAY)
            _, umbral = cv2.threshold(gris, 150, 255, cv2.THRESH_BINARY)
            texto_completo = pytesseract.image_to_string(umbral, lang='eng').strip()
            os.remove(imagen_ruta)
            return texto_completo
    except Exception as e:
        logger.error(f"Error al procesar OCR del PDF {pdf_ruta}: {e}")
        return ""

def buscar_bastidor(texto):
    """Busca bastidores en el texto y devuelve el más probable."""
    try:
        texto = texto.strip()
        patron = re.compile(r'\b[A-Z0-9]{14,20}\b')  # Buscar secuencias entre 14 y 20 caracteres
        resultados = patron.findall(texto)
        if not resultados:
            return None
        
        # Priorizar el que tenga 17 caracteres exactos si existe
        for bastidor in resultados:
            if len(bastidor) == 17:
                return bastidor
        
        # Si no hay de 17 caracteres exactos, devolver el más largo disponible
        return sorted(resultados, key=len, reverse=True)[0]
    except Exception as e:
        logger.error(f"Error al buscar bastidor en el texto: {e}")
        return None

def limpiar_bastidor(bastidor):
    """Limpia el bastidor eliminando caracteres no válidos y corrigiendo duplicaciones erróneas."""
    bastidor = re.sub(r'[^A-Z0-9]', '', bastidor)  # Eliminar caracteres no alfanuméricos
    bastidor = bastidor.replace('O', '0').replace('I', '1').replace('Q', '0')
    
    # Si el bastidor tiene entre 14 y 20 caracteres, lo pasamos a rapidfuzz antes de recortarlo
    if 14 <= len(bastidor) <= 20:
        return bastidor
    
    # Si el bastidor tiene más de 17 caracteres, recortarlo; si tiene menos, descartarlo
    if len(bastidor) > 17:
        bastidor = bastidor[:17]
    elif len(bastidor) < 17:
        logger.error(f"Bastidor inválido detectado (menos de 17 caracteres): {bastidor}")
        return None
    
    return bastidor

def indexar_carpetas(base_folder_x):
    """Indexa todas las carpetas y subcarpetas dentro de una carpeta base."""
    try:
        folder_index = {}
        for root, dirs, _ in os.walk(base_folder_x):
            for folder in dirs:
                folder_index[folder] = os.path.join(root, folder)
        return folder_index
    except Exception as e:
        logger.error(f"Error al indexar las carpetas en {base_folder_x}: {e}")
        return {}

def encontrar_carpeta_bastidor(bastidor, folder_index, umbral=82):
    """Encuentra la carpeta más cercana al bastidor usando rapidfuzz."""
    carpetas = list(folder_index.keys())
    mejor_coincidencia, puntuacion, _ = process.extractOne(bastidor, carpetas, scorer=fuzz.ratio)
    
    if puntuacion >= umbral:
        logger.info(f"Bastidor '{bastidor}' asignado a carpeta '{mejor_coincidencia}' con {puntuacion}% de similitud")
        return folder_index[mejor_coincidencia]
    else:
        logger.error(f"No se encontró una carpeta coincidente para el bastidor: {bastidor}")
        return None

def procesar_pdf(pdf_ruta, folder_index):
    """Procesa un PDF para buscar el bastidor y moverlo a la carpeta correspondiente si existe."""
    pytesseract.pytesseract.tesseract_cmd = r'C:\Program Files\Tesseract-OCR\tesseract.exe'

    texto = extraer_texto_pdf(pdf_ruta) or extraer_texto_ocr(pdf_ruta)
    bastidor = buscar_bastidor(texto)
    
    if not bastidor:
        logger.error(f"No se encontró un bastidor en el archivo: {pdf_ruta}")
        return

    bastidor_limpio = limpiar_bastidor(bastidor)
    if not bastidor_limpio:
        return
    
    carpeta_destino = encontrar_carpeta_bastidor(bastidor_limpio, folder_index)
    
    if carpeta_destino:
        destino = os.path.join(carpeta_destino, os.path.basename(pdf_ruta))
        os.rename(pdf_ruta, destino)
        logger.info(f"Archivo {pdf_ruta} movido a {carpeta_destino}")

def procesar_pdfs_en_carpeta(carpeta_origen, base_folder_x):
    """Procesa todos los PDFs en una carpeta y sus subcarpetas."""
    folder_index = indexar_carpetas(base_folder_x)
    for root, _, files in os.walk(carpeta_origen):
        for file in files:
            if file.lower().endswith('.pdf'):
                ruta_pdf = os.path.join(root, file)
                procesar_pdf(ruta_pdf, folder_index)

if __name__ == "__main__":
    carpeta_origen = input("Introduce la ruta de la carpeta que contiene los PDFs: ")
    base_folder_x = input("Introduce la ruta de la carpeta base X: ")
    procesar_pdfs_en_carpeta(carpeta_origen, base_folder_x)
